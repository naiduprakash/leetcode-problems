# 2. Add Two Numbers

## Problem Description:

You can find the problem statement on [https://leetcode.com/problems/add-two-numbers/](https://leetcode.com/problems/add-two-numbers/).

## Solution:

```js
/**
 * Definition for singly-linked list.
 * function ListNode(val, next) {
 *     this.val = (val===undefined ? 0 : val)
 *     this.next = (next===undefined ? null : next)
 * }
 */
/**
 * @param {ListNode} l1
 * @param {ListNode} l2
 * @return {ListNode}
 */

function addTwoNumbers(a, b) {
    let head = new ListNode();
    let tail = head;
    let carry = 0;
    while (a || b || carry) {
        if (a) { carry += a.val; a = a.next; }
        if (b) { carry += b.val; b = b.next; }
        let digit = carry % 10;
        carry = carry / 10 | 0;
        tail = tail.next = new ListNode(digit);
    }
    return head.next;
};
```

## Code Explanation:

1. ListNode Definition:
```js
function ListNode(val, next) {
    this.val = (val === undefined ? 0 : val);
    this.next = (next === undefined ? null : next);
}
```
This function defines a node in a singly-linked list. Each node contains:
- `val`: The value stored in the code.
- `next`: A reference to the next node in the list.   

If `val` is not provided, it defaults to 0. If `next` is not provided, it defaults to `null`.

2. Function definition for `addTwoNumbers`:   
This function takes two singly-linked lists (`a` and `b`) representing non-negative integers, where each node contains a single digit. The digits are stored in reverse order, and each of their nodes contains a single digit. The function adds the two numbers and returns the sum as a linked list.   

## Detailed Walkthrough:
1. Initialization:
```js
let head = new ListNode();
let tail = head;
let carry = 0;
```
- `head`: A dummy node that will eventually point to the head of resulting linked list.
- `tail`: A pointer to the current node in the rsulting linked list.
- `carry`: A variable to store the carry-over value during addition.

2. Main Loop:
```js
while (a || b || carry) {
    if (a) { carry += a.val; a = a.next; }
    if (b) { carry += b.val; b = b.next; }
    let digit = carry % 10;
    carry = carry / 10 | 0;
    tail = tail.next = new ListNode(digit);
}
```
- The loop continues as long as there are nodes in either `a` or `b` or there is non-zero `carry`.
- `if (a) { carry += a.val; a = a.next; }`: If there is a node in list `a`, add its value to `carry` and move to the next node.
- `if (b) { carry += b.val; b = b.next; }`: If there is a node in list `b`, add its value to `carry` and move to the next node.
- `let digit = carry % 10;`: The digit to store in the current node of the result is the remainder of `carry` divided by 10.
- `carry = carry / 10 | 0;`: Update `carry` to be the quotient of `carry` divided by 10 (using bitwise OR with 0 to truncate the decimal part).
- `tail = tail.next = new ListNode(digit);`: Create a new node with the calculated `digit` and append it to the result list. Move the tail pointer to this new node.
- `return head.next;`: `head` is a dummy node, so `head.next` is the actual head of the resulting linked list.

## Example Walkthrough:

**Input**:    
lets consider the numbers `342` and `465`. These numbers are represented as linked lists in reverse order:
- `a`: 2->4->3 (represents the number 342)
- `b`: 5->6->4 (represents the number 465)   

**Initial State**:
- `head` and `tail` are initialized to a dummy node with value 0.
- `carry` is intitalized to 0.

**Iteration 1**:
- `a` node value: 2
- `b` node value: 5
- Sum: 2 + 5 + 0 (carry) = 7
- Digit to store: 7%10 = 7
- New carry: 7/10 | 0 = 0   

New List: 7

**Iteration 2**:
- Move to the next nodes: `a`:4, `b`:6
- Sum: 4+6+0(carry) = 10
- Digit to store: 10%10 = 0
- New carry: 10/10 | 0 = 1   

New List: 7->0

**Iteration 3**:
- Move to the next nodes: `a`:3, `b`:4
- Sum: 3+4+1(carry) = 8
- Digit to store: 8%10 = 8
- New carry: 8/10 | 0 = 0

New List: 7->0->8

**Final State**:
- Both `a` and `b` are null, and `carry` is 0.
- The resulting linked list is `7->0->8`, which represents the number 807 (342+465).